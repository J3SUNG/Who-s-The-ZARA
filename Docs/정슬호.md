[1주차](#1주차)  
[2주차](#2주차)

# 1주차

#### 2023/7/17(월)

# 📌what i did

- 주간 스프린트 회의 및 지라 이슈 생성 및 조직화 하기
- 컨설턴트 님과 주간 팀 미팅(기능 명세서 역할, 기간, 더 상세히 작성하기)
- 게임 설명 모달 부분에 슬라이드 효과 포함

# 📌issue & solution

## 📖position css 사용 이후 onClick 무응답

### 💢issue

position에 absolute 사용 한뒤에 원하는 슬라이드 효과나 호버 효과가 일어나지 않았다.

### 👀solution

position을 Normal-flow를 벗어나게 하여 다른 태그와 겹치게 되는 경우 적절한 z-index를 필수로 주어서 겹치는 부분에 대해 어떤 태그가 더 앞에 있는 것인지 명확히 해주자, 생각해보면 당연한건데 이걸 못찾아서 1시간을 넘게 헤맸다.

# 📌what i learned

# 📌to do

- JWT를 이용한 인증, 인가 로직 개발

#### 2023/7/18(화)

# 📌what i did

- 주간 스프린트 회의 및 지라 이슈 생성 및 조직화 하기
- 컨설턴트 님과 주간 팀 미팅(기능 명세서 역할, 기간, 더 상세히 작성하기)
- 게임 설명 모달 부분에 슬라이드 효과 포함

# 📌issue & solution

## 📖position css 사용 이후 onClick 무응답

### 💢issue

position에 absolute 사용 한뒤에 원하는 슬라이드 효과나 호버 효과가 일어나지 않았다.

### 👀solution

position을 Normal-flow를 벗어나게 하여 다른 태그와 겹치게 되는 경우 적절한 z-index를 필수로 주어서 겹치는 부분에 대해 어떤 태그가 더 앞에 있는 것인지 명확히 해주자, 생각해보면 당연한건데 이걸 못찾아서 1시간을 넘게 헤맸다.

# 📌what i learned

# 📌to do

- JWT를 이용한 인증, 인가 로직 개발

#### 2023/7/18(화)

# 📌what i did

- signup 로직 및 signup form 입력 값들 검증
- login 로직

# 📌issue & solution

# 📌what i learned

## 📖hooks 사용하기

```typescript
// before
const [email, setEmail] = useState('');
const [isEmailValid, setIsEmailValid] = useState(false);

const [nickname, setNickname] = useState('');
const [isNicknameValid, setIsNicknameValid] = useState(false);

const [password, setPassword] = useState('');
const [isPasswordValid, setIsPasswordValid] = useState(false);

const [confirmPassword, setConfirmPassword] = useState('');
const [isConfirmPasswordValid, setIsConfirmPasswordValid] = useState(false);

const [verificationCode, setVerificationCode] = useState('');
const [isVerificationCodeValid, setIsVerificationCodeValid] = useState(false);

const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// Function to validate nickname format
const validateNickname = (nickname) => {
  return nickname.length > 0 && nickname.length <= 10;
};

// Function to validate password format
const validatePassword = (password) => {
  const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d).{6,}$/;
  return passwordRegex.test(password);
};

// Function to handle input changes and update validity state
const handleInputChange = (inputName, inputValue) => {
  switch (inputName) {
    case 'email':
      setEmail(inputValue);
      setIsEmailValid(validateEmail(inputValue));
      break;
    case 'nickname':
      setNickname(inputValue);
      setIsNicknameValid(validateNickname(inputValue));
      break;
    case 'password':
      setPassword(inputValue);
      setIsPasswordValid(validatePassword(inputValue));
      break;
    case 'confirmPassword':
      setConfirmPassword(inputValue);
      setIsConfirmPasswordValid(inputValue === password);
      break;
    case 'verificationCode':
      setVerificationCode(inputValue);
      setIsVerificationCodeValid(inputValue.length === 8);
      break;
    default:
      break;
  }
};
```

- 똑같은 로직 반복되는게 많아서 hooks로 빼서 사용

```typescript
// after

// 커스텀 훅
import { useState } from 'react';

interface returnUseFormField {
  value: string;
  isValid: boolean;
  handleChange: (newValue: string) => void;
  clear: () => void;
}

function useFormField(
  initialValue: string,
  validator: (value: string) => boolean,
): returnUseFormField {
  const [value, setValue] = useState(initialValue);
  const [isValid, setIsValid] = useState(false);

  const handleChange = (newValue: string) => {
    setValue(newValue);
    setIsValid(validator(newValue));
  };

  const clear = () => {
    setValue('');
    setIsValid(false);
  };

  return {
    value,
    isValid,
    handleChange,
    clear,
  };
}

export default useFormField;

// 실제 사용
const emailField = useFormField('', validateEmail);
const nicknameField = useFormField('', validateNickname);
const passwordField = useFormField('', validatePassword);
const confirmPasswordField = useFormField(
  '',
  (value) => value === passwordField.value,
);
```

# 📌to do

- JWT를 이용한 인증, 인가 로직 개발(~ing)

#### 2023/7/19(수)

# 📌what i did

- resetPW 기능 구현
- cookie 관리 및 context api로 전역 상태 관리 로직 만들기
- promise 상태에 따른 react-toast 만들기
- EC2 생성 및 기본 세팅, docker, docker-compose, jenkins 등 설치

# 📌issue & solution

## 📖 test-case 설계

### 💢 issue

프로젝트마다 항상 제일 걱정하는 test-case 결정하기, 소프트웨어공학 강의를 듣고 몇몇의 선정 전략 등을 알고있지만 역시 겨우 7주간 6명이서 빠르게 많은 양을 해야하는 우리 프로젝트에 테스트 코드를 작성하는 것 자체를 고민 중이다, 결국 1순위는 기간내에 프로젝트 완성(최상위 우선순위 기능들 모두 구현하기)이므로..

### 👀 solution

#### 결론

지금까지 생각한 내 결론은 개발을 진행하면서 어떤 기능에대해 1번이상 에러가 발생한다면 해당 기능을 검증할 테스트 코드를 따로 만든다 `ex) 기능 A 또는 어떤 코드 덩어리? A를 완성, 기능 B를 하다가 기능 A가 오류남 => 카운트 1번 해당 오류를 검증 할 테스트 코드 작성 필요`

#### 이유

진짜 최소한의 테스트 케이스를 선정해야 한다는 생각에 나만의 선정방법을 생각해봤다. 코드에 버그가 1번 발생한 부분은 2번, 3번 발생할 확률도 높다는 그런 통계를 소프트웨어공학에서 배운 기록을 근거로 정했다.

#### 단점

- 1번이상 오류라고 했는데 프로젝트 크기가 커지면서 매번 모든 기능이 오류가 난다면 결국 전부 테스트 해야한다, 아직 감이 없어서 너무 테스트 케이스를 많이 작성해야한다면 2번으로 수정 할 수도있다.
- 그냥 내가 만든 테스트 케이스 설계 법이라서 어떤 위험성이 있는지 모름..

# 📌what i learned

- 쿠키 accessToken expire 자체 설정해서 프론트단에서 만료 확인 및 accessToken 요청하기(내가 본 그림에서는 백에서 만료확인)
- context api 사용법 다시 상기하기
- EC2 인스턴스 우분투로 만들고 여러 필요한 프로그램 설치하기, 옛날에 아무것도 모르고 배우던 재미없는 리눅스 명령어를 쓰게 되는날이 올줄 몰랐다.

# 📌to do

- debounce 함수 import 한것 onClick에 적용 시켜 주기
- accessToken 만료시 로직 백엔드와 상의 및 구현하기

#### 2023/7/20(목)

# 📌what i did

- change pw api call 및 UI 구현
- 회원 탈퇴 api call 및 UI 구현
- 에러코드 처리를 constant.ts 파일로 따로 관리하도록 리팩토링

# 📌issue & solution

# 📌what i learned

## 📖 기능명세서 중요성

jira도 branch도 기능명세서를 참고하면서 개발해나가고 있는데, 사실 기능명세서를 완벽하게 구체적으로 작성하지 않았다. 그러다보니 추가적으로 해야할 소통이 더 많았다.`ex) 비밀번호 작성시 문자열 length 범위 및 특수문자 필수 여부, accessToken프론트에서 만료기간을 확인할지, 백엔드로 보내서 백엔드에서 만료기간을 확인할지 등`

# 📌to do

#### 2023/7/21(금)

# 📌what i did

- access token 재발급 로직
- docker와 docker compose 공부

# 📌issue & solution

## 📖 token 재발급

토큰이 필요한 api call에서 access token을 재발급 해야한다면 재발급하고 원래 처음 의도했던 api call을 다시 사용자가 실행하지 않고 자동으로 요청 되도록 로직을 짜려했다.

## 💢 issue

```typescript
export const changePassword = async () => {
  try{
    ... 비밀번호_변경_요청(promise_toast_msg_띄워줌)
  } catch (error) {
    if(토큰_만료) {
      const 토큰_재발급_결과 = await 토큰_재발급_요청
      	if(토큰_재발급_결과) {
          changePassword() // 재귀로 다시 실행
        }
    }
  }
}
```

이렇게 재귀로 했더니 너무 들여쓰기 depth가 많아서 가독성이 마음에 안들었다(실제로는 훨씬 길다), 또한 재귀라서 따로 함수로 빼기도 힘들었다. 여기서 토큰*재발급*결과는 내가 만든 함수로 true or false를 반환

## 👀 solution

```typescript
export const changePassword = async () => {
  try{
    ... 비밀번호_변경_요청(promise_toast_msg_띄워줌)
  } catch{
    if(토큰_만료) {
      try{
		const originalRequest = error.config!;
		await reissueAccessToken(getRefreshToken());
		originalRequest.headers.Authorization = `Bearer ${getAccessToken()}`;
		const reChangePasswordResult = await axios(originalRequest);
		return reChangePasswordResult;
      } catch (error) {
        return error
      }
    }
  }
}
```

이렇게 `reissueAccessToken`에서 에러를 일으키게 만들어 `try, catch`로 잡도록 했다. 또한 `const originalRequest = error.config!;` 이렇게 처음 요청을 변수에 담아둘 수도 있더라. 이렇게하면 해당 토큰 만료시 로직을 따로 함수로 빼기도 간편

# 📌what i learned

# 📌to do

- user my page info 보여주기
- 아키텍처 구체화 및 CI/CD 배포

# 📌1주차 KPT 회고

## 👍keep

- 의지, 열정

## 👎problem

- 구체적이지 않은 기능 명세서
- 구체적이지 않은 일정, 우선순위

## 🚀try

- 아키텍처 설계 및 CI/CD 공부
- open vidu 구현 실습 및 프로젝트에 구현

# 2주차

#### 2023/7/24(월)

# 📌what i did

- 소켓으로 방(채팅방) 생성 및 관리 로직에 관련한 기능명세서 작성
- 아키텍처 피드백 및 수정
- open vidu 도커로 컨테이너 띄우기

# 📌issue & solution

## 📖게임 진행 중 사용 프로토콜

### 💢 issue

기능 명세서에 턴제 게임이라고 설명하고, 턴을 중심으로 진행하다 보니 굳이 실시간의 웹소켓이 아니라 http를 써도 되지 않나 고민함

### 👀 solution

대부분의 웹 게임에서 웹 소켓을 사용하며, 당장 http를 사용하여 생길 수 있는 문제에대하여 떠오르지 않지만 추후 문제 될 수 있으니 그냥 웹 소켓을 사용또한, 실시간 통신이 필요한 기능을 추가하는 확장성을 고려해서도 웹 소켓으로 하기로 함

# 📌what i learned

- stompjs의 connection, subscribe, publish 등의 개념
- stomp에서 만드는 client 객체 전역으로 관리하도록 해야함

# 📌to do

- docker-compose 공부
- stompjs 라이브러리 사용한 채팅방 구현
