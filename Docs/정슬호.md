# 1주차

<details>
<summary>접기/펼치기</summary>

#### 2023/7/17(월)

# 📌what i did

- 주간 스프린트 회의 및 지라 이슈 생성 및 조직화 하기
- 컨설턴트 님과 주간 팀 미팅(기능 명세서 역할, 기간, 더 상세히 작성하기)
- 게임 설명 모달 부분에 슬라이드 효과 포함

# 📌issue & solution

## 📖position css 사용 이후 onClick 무응답

### 💢issue

position에 absolute 사용 한뒤에 원하는 슬라이드 효과나 호버 효과가 일어나지 않았다.

### 👀solution

position을 Normal-flow를 벗어나게 하여 다른 태그와 겹치게 되는 경우 적절한 z-index를 필수로 주어서 겹치는 부분에 대해 어떤 태그가 더 앞에 있는 것인지 명확히 해주자, 생각해보면 당연한건데 이걸 못찾아서 1시간을 넘게 헤맸다.

# 📌what i learned

# 📌to do

- JWT를 이용한 인증, 인가 로직 개발

#### 2023/7/18(화)

# 📌what i did

- 주간 스프린트 회의 및 지라 이슈 생성 및 조직화 하기
- 컨설턴트 님과 주간 팀 미팅(기능 명세서 역할, 기간, 더 상세히 작성하기)
- 게임 설명 모달 부분에 슬라이드 효과 포함

# 📌issue & solution

## 📖position css 사용 이후 onClick 무응답

### 💢issue

position에 absolute 사용 한뒤에 원하는 슬라이드 효과나 호버 효과가 일어나지 않았다.

### 👀solution

position을 Normal-flow를 벗어나게 하여 다른 태그와 겹치게 되는 경우 적절한 z-index를 필수로 주어서 겹치는 부분에 대해 어떤 태그가 더 앞에 있는 것인지 명확히 해주자, 생각해보면 당연한건데 이걸 못찾아서 1시간을 넘게 헤맸다.

# 📌what i learned

# 📌to do

- JWT를 이용한 인증, 인가 로직 개발

#### 2023/7/18(화)

# 📌what i did

- signup 로직 및 signup form 입력 값들 검증
- login 로직

# 📌issue & solution

# 📌what i learned

## 📖hooks 사용하기

```typescript
// before
const [email, setEmail] = useState('');
const [isEmailValid, setIsEmailValid] = useState(false);

const [nickname, setNickname] = useState('');
const [isNicknameValid, setIsNicknameValid] = useState(false);

const [password, setPassword] = useState('');
const [isPasswordValid, setIsPasswordValid] = useState(false);

const [confirmPassword, setConfirmPassword] = useState('');
const [isConfirmPasswordValid, setIsConfirmPasswordValid] = useState(false);

const [verificationCode, setVerificationCode] = useState('');
const [isVerificationCodeValid, setIsVerificationCodeValid] = useState(false);

const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// Function to validate nickname format
const validateNickname = (nickname) => {
  return nickname.length > 0 && nickname.length <= 10;
};

// Function to validate password format
const validatePassword = (password) => {
  const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d).{6,}$/;
  return passwordRegex.test(password);
};

// Function to handle input changes and update validity state
const handleInputChange = (inputName, inputValue) => {
  switch (inputName) {
    case 'email':
      setEmail(inputValue);
      setIsEmailValid(validateEmail(inputValue));
      break;
    case 'nickname':
      setNickname(inputValue);
      setIsNicknameValid(validateNickname(inputValue));
      break;
    case 'password':
      setPassword(inputValue);
      setIsPasswordValid(validatePassword(inputValue));
      break;
    case 'confirmPassword':
      setConfirmPassword(inputValue);
      setIsConfirmPasswordValid(inputValue === password);
      break;
    case 'verificationCode':
      setVerificationCode(inputValue);
      setIsVerificationCodeValid(inputValue.length === 8);
      break;
    default:
      break;
  }
};
```

- 똑같은 로직 반복되는게 많아서 hooks로 빼서 사용

```typescript
// after

// 커스텀 훅
import { useState } from 'react';

interface returnUseFormField {
  value: string;
  isValid: boolean;
  handleChange: (newValue: string) => void;
  clear: () => void;
}

function useFormField(
  initialValue: string,
  validator: (value: string) => boolean,
): returnUseFormField {
  const [value, setValue] = useState(initialValue);
  const [isValid, setIsValid] = useState(false);

  const handleChange = (newValue: string) => {
    setValue(newValue);
    setIsValid(validator(newValue));
  };

  const clear = () => {
    setValue('');
    setIsValid(false);
  };

  return {
    value,
    isValid,
    handleChange,
    clear,
  };
}

export default useFormField;

// 실제 사용
const emailField = useFormField('', validateEmail);
const nicknameField = useFormField('', validateNickname);
const passwordField = useFormField('', validatePassword);
const confirmPasswordField = useFormField(
  '',
  (value) => value === passwordField.value,
);
```

# 📌to do

- JWT를 이용한 인증, 인가 로직 개발(~ing)

#### 2023/7/19(수)

# 📌what i did

- resetPW 기능 구현
- cookie 관리 및 context api로 전역 상태 관리 로직 만들기
- promise 상태에 따른 react-toast 만들기
- EC2 생성 및 기본 세팅, docker, docker-compose, jenkins 등 설치

# 📌issue & solution

## 📖 test-case 설계

### 💢 issue

프로젝트마다 항상 제일 걱정하는 test-case 결정하기, 소프트웨어공학 강의를 듣고 몇몇의 선정 전략 등을 알고있지만 역시 겨우 7주간 6명이서 빠르게 많은 양을 해야하는 우리 프로젝트에 테스트 코드를 작성하는 것 자체를 고민 중이다, 결국 1순위는 기간내에 프로젝트 완성(최상위 우선순위 기능들 모두 구현하기)이므로..

### 👀 solution

#### 결론

지금까지 생각한 내 결론은 개발을 진행하면서 어떤 기능에대해 1번이상 에러가 발생한다면 해당 기능을 검증할 테스트 코드를 따로 만든다 `ex) 기능 A 또는 어떤 코드 덩어리? A를 완성, 기능 B를 하다가 기능 A가 오류남 => 카운트 1번 해당 오류를 검증 할 테스트 코드 작성 필요`

#### 이유

진짜 최소한의 테스트 케이스를 선정해야 한다는 생각에 나만의 선정방법을 생각해봤다. 코드에 버그가 1번 발생한 부분은 2번, 3번 발생할 확률도 높다는 그런 통계를 소프트웨어공학에서 배운 기록을 근거로 정했다.

#### 단점

- 1번이상 오류라고 했는데 프로젝트 크기가 커지면서 매번 모든 기능이 오류가 난다면 결국 전부 테스트 해야한다, 아직 감이 없어서 너무 테스트 케이스를 많이 작성해야한다면 2번으로 수정 할 수도있다.
- 그냥 내가 만든 테스트 케이스 설계 법이라서 어떤 위험성이 있는지 모름..

# 📌what i learned

- 쿠키 accessToken expire 자체 설정해서 프론트단에서 만료 확인 및 accessToken 요청하기(내가 본 그림에서는 백에서 만료확인)
- context api 사용법 다시 상기하기
- EC2 인스턴스 우분투로 만들고 여러 필요한 프로그램 설치하기, 옛날에 아무것도 모르고 배우던 재미없는 리눅스 명령어를 쓰게 되는날이 올줄 몰랐다.

# 📌to do

- debounce 함수 import 한것 onClick에 적용 시켜 주기
- accessToken 만료시 로직 백엔드와 상의 및 구현하기

#### 2023/7/20(목)

# 📌what i did

- change pw api call 및 UI 구현
- 회원 탈퇴 api call 및 UI 구현
- 에러코드 처리를 constant.ts 파일로 따로 관리하도록 리팩토링

# 📌issue & solution

# 📌what i learned

## 📖 기능명세서 중요성

jira도 branch도 기능명세서를 참고하면서 개발해나가고 있는데, 사실 기능명세서를 완벽하게 구체적으로 작성하지 않았다. 그러다보니 추가적으로 해야할 소통이 더 많았다.`ex) 비밀번호 작성시 문자열 length 범위 및 특수문자 필수 여부, accessToken프론트에서 만료기간을 확인할지, 백엔드로 보내서 백엔드에서 만료기간을 확인할지 등`

# 📌to do

#### 2023/7/21(금)

# 📌what i did

- access token 재발급 로직
- docker와 docker compose 공부

# 📌issue & solution

## 📖 token 재발급

토큰이 필요한 api call에서 access token을 재발급 해야한다면 재발급하고 원래 처음 의도했던 api call을 다시 사용자가 실행하지 않고 자동으로 요청 되도록 로직을 짜려했다.

## 💢 issue

```typescript
export const changePassword = async () => {
  try{
    ... 비밀번호_변경_요청(promise_toast_msg_띄워줌)
  } catch (error) {
    if(토큰_만료) {
      const 토큰_재발급_결과 = await 토큰_재발급_요청
      	if(토큰_재발급_결과) {
          changePassword() // 재귀로 다시 실행
        }
    }
  }
}
```

이렇게 재귀로 했더니 너무 들여쓰기 depth가 많아서 가독성이 마음에 안들었다(실제로는 훨씬 길다), 또한 재귀라서 따로 함수로 빼기도 힘들었다. 여기서 토큰*재발급*결과는 내가 만든 함수로 true or false를 반환

## 👀 solution

```typescript
export const changePassword = async () => {
  try{
    ... 비밀번호_변경_요청(promise_toast_msg_띄워줌)
  } catch{
    if(토큰_만료) {
      try{
		const originalRequest = error.config!;
		await reissueAccessToken(getRefreshToken());
		originalRequest.headers.Authorization = `Bearer ${getAccessToken()}`;
		const reChangePasswordResult = await axios(originalRequest);
		return reChangePasswordResult;
      } catch (error) {
        return error
      }
    }
  }
}
```

이렇게 `reissueAccessToken`에서 에러를 일으키게 만들어 `try, catch`로 잡도록 했다. 또한 `const originalRequest = error.config!;` 이렇게 처음 요청을 변수에 담아둘 수도 있더라. 이렇게하면 해당 토큰 만료시 로직을 따로 함수로 빼기도 간편

# 📌what i learned

# 📌to do

- user my page info 보여주기
- 아키텍처 구체화 및 CI/CD 배포

# 📌1주차 KPT 회고

## 👍keep

- 의지, 열정

## 👎problem

- 구체적이지 않은 기능 명세서
- 구체적이지 않은 일정, 우선순위

## 🚀try

- 아키텍처 설계 및 CI/CD 공부
- open vidu 구현 실습 및 프로젝트에 구현

</details>

<br>

# 2주차

<details>
<summary>접기/펼치기</summary>

#### 2023/7/24(월)

# 📌what i did

- 소켓으로 방(채팅방) 생성 및 관리 로직에 관련한 기능명세서 작성
- 아키텍처 피드백 및 수정
- open vidu 도커로 컨테이너 띄우기

# 📌issue & solution

## 📖게임 진행 중 사용 프로토콜

### 💢 issue

기능 명세서에 턴제 게임이라고 설명하고, 턴을 중심으로 진행하다 보니 굳이 실시간의 웹소켓이 아니라 http를 써도 되지 않나 고민함

### 👀 solution

대부분의 웹 게임에서 웹 소켓을 사용하며, 당장 http를 사용하여 생길 수 있는 문제에대하여 떠오르지 않지만 추후 문제 될 수 있으니 그냥 웹 소켓을 사용또한, 실시간 통신이 필요한 기능을 추가하는 확장성을 고려해서도 웹 소켓으로 하기로 함

# 📌what i learned

- stompjs의 connection, subscribe, publish 등의 개념
- stomp에서 만드는 client 객체 전역으로 관리하도록 해야함

# 📌to do

- docker-compose 공부
- stompjs 라이브러리 사용한 채팅방 구현

#### 2023/7/25(화)

# 📌what i did

- Stomp 채팅방 만들기
- docker로 openvidu 배포

# 📌issue & solution

## 📖open vidu port

### 💢 issue

open vidu에서는 내부적으로 Nginx를 사용하는데 해당 Nginx에서 http, https 포트인 80, 443을 사용한다, 근데 우리는 자체적으로 리버스 프록시 역할을하는 Nginx를 80과 443 포트로 써야하기 때문에 둘중 하나를 바꿔야 했다.

### 👀 solution

사용자 접근성에서 봤을때, 우리가 자체적으로 사용하는 리버스 프록시 역할의 Nginx을 443이 아닌 다른 포트로 변경하면 도메인 접속시 `https:example.com:5000` 같이 뒤에 포트번호를 붙여야하기 때문에, 굉장히 찜찜하다. open vidu의 내부에 있는 nginx 80, 433 포트를 바꾸기로 했다.

```
근데 이 바꾸는 과정이 또 한참 걸렸다.
일단 80번 포트는 ssl 인증을 open vidu 자체적으로 해줄때 사용한다고 한다, 그래서 ssl 인증서를 직접 발급받고 특정 폴더에 넣어서 80번 포트를 사용안하도록 했다.
443 포트는 18181포트로 바꿨는데 처음에 444포트가 아무리 해도 안되서 포트번호 바꿔봤더니 되었다. 사용중인 포트번호들 목록 확인해서 444포트 사용안하는거 확인했다고 생각했는데, 뭔가 더 확인했어야 하나 보다 내일 마저 찾아보자
```

# 📌what i learned

# 📌to do

- CI/CD 완벽하게 구성하기

#### 2023/7/26(수)

# 📌what i did

- Jenkinsfile 만들어서 pipeline 구축

# 📌issue & solution

## 📖 web hooks payload 추출

### 💢 issue

git Lab에서 Jenkins로 https 형식의 web hooks을 보낼때 web hooks에 대한 정보가 payload에 담겨서 온다(MR이 오픈이됬는지, merged 된건지, source branch 이름 등등...) 처음에 나는 Jenkins에서 git Lab plugin을 사용하여 CI/CD를 하려했는데 아무리 검색해도 payload를 변수로 사용하는 방법이 없다.

### 👀 solution

그러다가 git Lab plugin으로는 payload에 담긴 내용들을 추출할 수 없다는걸 발견했고 Generic web hooks plugin이라는 다른 플러그인을 사용하였다`(그 이후로도 설정에서 post parameter를 add하여서 변수로 받아야 사용가능 하다는 것도 찾는데 몇시간이나 걸림)` 나는 MR 이벤트에서도 open과 merged 이벤트에서 CI/CD를 진행하기로 했으므로 각각의 경우에 대해서 직접 콘솔을 찍어보고 payload를 확인 및 Jenkinsfile에 when으로 조건을 걸어 2가지 스테이지를 구분하였다.

# 📌what i learned

- Jenkins 문법 및 작성하기

# 📌to do

- CI/CD 완벽하게 구성하기

#### 2023/7/27(목)

# 📌what i did

- 아키텍처 설계도를 기반한 CI/CD 배포 성공

# 📌issue & solution

## 📖 docker container안에서 docker 명령어 사용

### 🙏 나의 의도

내가 구상한 Jenkins 과정은 다음과 같다

1. docker로 띄운 Jenkins container안에서 우리 git repo를 pull
2. git repo 안에 compose.yaml을 사용하여 docker compose up 명령어 사용`(우리는 이 yaml에 도커 이미지 빌드 및 실행이 포함 됨)`
3. 배포 성공

### 💢 issue

- jenkins container에서 docker compose 명령어 사용 어려움(자료 부족, docker-compose 플러그인 업데이트 6년전...)
- jenkins container에서 pull해도 container 안에서 pull이 되는 것을 인지 하지 못함`(EC2 호스트에서 pull받고 docker compose up 해야배포 됨)`

### 👀 solution

그러다가 어떻게든 jenkins 컨테이너 안에서 docker 명령어 써서 해결하려다가 못하고 다른 조원분들 방법을 보고 참고함 과정은

1. jenkins에서는 호스트 EC2와 ssh로 연결
2. jenkins에서 실행하지 않고 호스트에 쉘 스크립트를 수행하도록 지시

이걸 우리 CI/CD에 적용하여 총 과정을 정리하면

1. git Lab Web hooks(MR)
2. Jenkins에서 MR open인지 MR merged인지 확인
3. MR open, merged에 따라 적당한 브랜치 git pull
4. Jenkins안에서 pull 받았지만 볼륨(-v) 옵션으로 호스트에도 파일 동기화됨
5. Jenkins에서 EC2에게 docker compose up 명령어 실행하도록 지시(SSH 연결로)

### 🏃 한계

나는 어떻게든 Jenkins container안에서 해결 하고 싶었다, 같은 컴퓨터 안인데 SSH로 연결해야한다는게 뭔가 깔끔하지 않은 느낌, 검색해본 docker demon 권한?을 줘서 실행할 수 있도록 하기, 여러가지 jenkins 플러그인들 써봤는데 뭐가 문제인지 모르고 시간만 쓰다가 결국 SSH로 수행함(CI/CD 보단 내 프론트 업무가 중요하니까) 다음 프로젝트에는 SSH 없이 깔끔하게 해보고 싶다

# 📌what i learned

- CI/CD 어렵다

# 📌to do

- stompjs로 채팅방 구현하기

#### 2023/7/28(금)

# 📌what i did

- 중간 발표
- 배포 오류 수정
- KPT 회고

# 📌issue & solution

## 📖 redis, spring boot 연결 오류

### 💢 issue

redis랑 spring boot가 아무리 해도 연동이 안된다. 같은 도커 네트워크에 포함 시켜보고, docker compose에 같이 넣어서 해보고(같은 compose 파일에 넣어서 compose up하면 디폴트 값으로 같은 도커 네트워크 쓰게 해준단다), redis 완료되기 전에 spring boot 먼저 완료 되면 안된대서 healthy check?라는걸 docker compose에 넣어보고 delay 걸어보고...

### 👀 solution

우리는 자체적인 redis는 6380 포트로, open vidu에 있는 redis는 6379포트(원래 redis default 포트)로 사용하도록 했다. 그래서 redis를 띄울 때, `docker run -p 6380:6380` 이라고 명령어를 썼다. 하지만, 알고보니 우리는 redis 이미지를 docker file로 직접 만들지 않고 docker pull redis로 기본 이미지를 사용하여 띄웠다. 그러면 도커 컨테이너 내부 포트에서 기본적으로 6379포트를 사용하게 되므로 우리 호스트에 6380포트와 기본 이미지인 컨테이너 내의 6379포트를 맵핑해야하므로 `docker run -p 6380:6379`가 맞았다.  
이거를 몇시간동안 헤맸는지..

# 📌what i learned

## 📖 리버스 프록시 역할인 Nginx에서 SSL 인증하면..

Nginx를 리버스 프록시로 사용하는 우리 아키텍처에서 나는 nginx.conf에서 SSL 인증을 하였다, 이렇게하면 Nginx와 spring boot간의 연결은 http를 사용한다. 즉, spring boot에서 https를 사용하기 위한 어떤 설정?코드?(프론트라 자세히 모름)가 필요 없어진다.

# 📌to do

- stompjs로 채팅방 구현하기
- 화면 전환 또는 컴포넌트 렌더링시 애니메이션 효과 주기

# 📚2주차 KPT 회고

## 👍keep

- 세분화된 역할 분담
- 생각보다 빠른 진행 및 개발 속도

## 👎problem

- 프로젝트 기획 의도 보충 필요
- 인프라 구축 너무 오래 걸렸음

## 🚀try

- 본격적인 웹 소켓 통신을 활용한 채팅방 및 게임 진행 백엔드와 통신
- 더 깔끔한 코드와 폴더 구조

</details>

<br>

# 3주차

<details>
<summary>접기/펼치기</summary>

#### 2023/7/31(월)

# 📌what i did

- stomp 구조 공부 및 이해, backend와 협의

# 📌issue & solution

## 📖 계속 되는 토큰과 로그인 상태에대한 고민

### 💢 issue

원래 `refreshToken`을 `cookie`에 넣고 js로 접근했는데 좀 더 엄격하게 `httpOnly` 옵션으로 js에도 접근못하게 설정했다.  
설정하니 기존에 나는 refreshToken 여부 기준으로 로그인 여부를 판별했는데 접근을 못하니 문제가 생김`(accessToken은 페이지 refresh하면 없어지는 그냥 변수라서 refreshToken 기준으로 했었음)`

### 👀 solution

accessToken을 기준으로 로그인 여부를 판별할 수 밖에 없었고,  
`axios interceptor`를 사용하기 위해 매 페이지에 사용할 local 변수로 `accessTokenLocalVar`을 선언그리고 나는 로그인 여부에 따라 동적으로 변하는 컴포넌트가 존재했기 때문에, 전역 상태로도 `accessToken`을 선언했다

> axios는 나는 ts 모듈로 따로 작성했는데 이 경우 전역 상태에 접근하지 못하기 때문에 axios interceptor 요청시 사용할 accessTokenLocalVar와 컴포넌트 변화 시킬 상태 accessToken 이렇게 2가지를 모두 사용한 것이다.

이렇게 하면 로그인하고 페이지 리로드하면 `accessTokenLocalVar, accessToken(state)` 둘다 없어져 버리며 페이지 라우팅을 하면 `accessTokenLocalVar`가 없어져 버린다.  
찾아본 결과 보안을 중시한다면 매 페이지에서 `useEffect`로 매번 토큰을 재발급 받아야한다고 한다...

```typescript
export const useFetchAccessToken = () => {
  const navigate = useNavigate();
  let accessToken = '';
  useEffect(() => {
    (async () => {
      try {
        const newAccessToken = await reissueAccessToken();
        accessToken = newAccessToken;
      } catch (error) {
        console.log(error);
        const { status } = (error as AxiosError).response!;
        //TODO: 빈 리프레쉬 토큰이면 에러 메세지 안띄움
        // if (status === ERROR_CODE_MAP.EMPTY_REFRESH_TOKEN) return;
        if (status === ERROR_CODE_MAP.IN_VALID_REFRESH_TOKEN) {
          toast.error('다시 로그인 해주세요.');
          navigate('/home');
        }
      }
    })();
  }, []);

  return accessToken;
};
```

이런 훅을 만들어서 매 페이지마다 사용했다..  
근데 여기서 리프레쉬 토큰이 없는경우(로그인 한적이 없는경우)에도 빈 리프레쉬 토큰으로 재발급 받으려 하기 때문에 이 부분을 또 분기시켜 줬다.  
여기서 리턴한 `accessToken`는 `localVar`과 `state` 두 군데 모두 넣어줬다

# 📌what i learned

## 📖react router에서 state 페이지간 전달

- context api로 사용했었는데 찾아보니 지원하는 문법이 있음

```typescript
// 전달
navigate('/newpage', { state: { value: 1234 } });

// 사용
const location = useLocation();
const number = location.state.value;
```

## 📖axios interceptors

- 매 요청전에 뭔가를 해야한다 혹은 매 응답에 뭔가를 해야한다면 쓰자
- 이번 프로젝트에서 요청에 `accessToken` 을 매번 넣었고, 응답에 토큰 만료인지 확인하여 재발급하는 로직을 넣었음

```typescript
// 요청 인터셉터 추가하기
axios.interceptors.request.use(
  function (config) {
    // 요청이 전달되기 전에 작업 수행
    return config;
  },
  function (error) {
    // 요청 오류가 있는 작업 수행
    return Promise.reject(error);
  },
);

// 응답 인터셉터 추가하기
axios.interceptors.response.use(
  function (response) {
    // 2xx 범위에 있는 상태 코드는 이 함수를 트리거 합니다.
    // 응답 데이터가 있는 작업 수행
    return response;
  },
  function (error) {
    // 2xx 외의 범위에 있는 상태 코드는 이 함수를 트리거 합니다.
    // 응답 오류가 있는 작업 수행
    return Promise.reject(error);
  },
);
```

## 📖토큰 관리

- `accessToken`은 변수 혹은 전역 상태로
- `refreshToken`은 `cookie`에 다음과 같은 설정으로 보안 신경쓰기`(원래 js에서 접근하도록 했었음 오늘 이 부분 수정)`

```typescript
cookies.set('refreshToken', refreshToken, {
  path: '/',
  secure: true,
  httpOnly: true,
});
```

# 📌to do

- 적당히 구현한 stomp test하기
- 빈 리프레쉬 토큰이면 구분할 수 있게 응답 달라고 백엔드에게 요청

#### 2023/8/1(화)

# 📌what i did

- 쿠키 관리 로직 리팩토링 및 수정

# 📌issue & solution

## 📖 중첩 try, catch 리팩토링

### 💢 issue

기존에는 `fnc A = try ~ catch`를 만들고 `fnc B = try A, catch` 이런식으로 B함수를 만들고 마지막으로 컴포넌트나 페이지 단에서 `try B, catch`이렇게 했다`(try catch로 함수를 만들고 계속 수정, 보완, 기능 추가를 해나가다 보니...)`  
`try, catch`가 너무 중첩 되어서 에러 처리가 복잡하고 어디서 잡히는지 어려워졌다.

### 👀 solution

`try, catch`를 최초 api 요청 로직에만 쓰고 페이지 혹은 컴포넌트 단에서는 try, catch를 쓰지않고 그냥 호출만 하도록 수정

## 📖 axios를 ts 모듈 대신 hooks으로 수정

### 💢 issue

`axios interceptor`는 필요시 `accessToken`을 재발급 받는데 전역상태의 `accessToken`을 가져오지 못하게 ts 모듈로 되어있어서 매 페이지마다 `localVar accessToken`을 선언하고 사용하였다 `(매 페이지마다 axios interceptor를 위한 accessTokenLocalVar과 컴포넌트 동적인 변경을 위한 context api의 tokenState를 설정 해주고 있었음)`

### 👀 solution

hooks으로 context api를 사용하도록 만들었다. `axios interceptor`를 hooks으로 만들어 전역상태로 `accessToken`을 set할 수 있게만듬  
해당 `axios interceptor instance`를 사용하는 곳도 hooks으로 만들어야 사용 가능

# 📌what i learned

## 📖 쿠키 사용 오해

나는 쿠키를 리프레쉬 토큰을 저장해놓고 사실상 로컬 스토리지 처럼 사용하였다`(그냥 cookie.get으로 코드상에서 접근하여 요청에 같이 보냄)`, 보안을 생각한 제대로된 관리 방법은 `httpOnly` 옵션으로 js코드로 접근하지 못하게하며 axios에서 `credentials = true`으로 헤더에 자동으로 담기도록 해야했다.  
spring에서도 쿠키를 받도록 하는 설정을 해주어 쿠키를 교환하도록 만들었다.

# 📌to do

- room, game 부분 api 명세서 작성
- stomp test하기

#### 2023/8/2(수)

# 📌what i did

- STOMP 공부
- ROOM 리스트 받아오기 및 생성 로직 작성

# 📌issue & solution

# 📌what i learned

## 📖 STOMP

생각보다 프론트에서 해줄 부분이 없었다.  
처음에는 이해를 잘 못해서 샘플 코드만 그대로 했는데, 프론트에서는 진짜 그 정도 부분이 다였다.

1. STOMP로 Client 객체 생성
2. client.active() 로 연결 시도
3. 연결된 상태에서 ROOM 들어가면 해당 ROOM CODE에 대하여 client.subscribe
4. 메세지 보낼때 client.publish

# 📌to do

- 상점 및 옷장 겸용 페이지 만들기
- ROOM 내에서 최대인원 수정
- 최근 게임 전적
- 게임 전적 통계(차트, 표 고려해보기)

#### 2023/8/3(수)

# 📌what i did

- 최근 전적 조회 api
- 프로필 게임 스탯 조회 api
- STOMP 방 로직 구상

# 📌what i learned

## 📖게임 개발 어려움

웹 소켓을 사용하여 게임이라는 실시간성이 중요하고 내 브라우저에서 동작이 다른 브라우저에 영향을 끼쳐야하다보니 일반적인 서버 - 클라이언트 구조보다 훨씬 어렵다  
여기서 영향을 끼치는 주체도 내 코드고 영향을 받는 주체도 내 코드이다  
room이라는 페이지 하나에 방장 기능과 일반 참여자 인원의 기능을 모두 넣으려니 약간 복잡하다 페이지를 따로 개설할까 고민중 ...

# 📌to do

- 게임 시작 전까지의 ROOM에서 모든 기능들 흐름 결정 및 구현하기

#### 2023/8/5(금)

# 📌what i did

- STOMP destination 구상 및 주고 받을 JSON 형태 회의
- 채팅방 CRUD 및 subscribe, unsubscribe 로직

# 📌issue & solution

## 📖일정 차질

### 💢issue

웹 소켓 프로토콜이 생소하고 STOMP에대한 이해가 부족하다 보니 채팅방기능 및 채팅방안에서 실시간으로 방 정보 수정에대하여 공유하는 그런 로직이 어려웠다.  
그래서 이 부분에서 일정이 조금 늦춰진거 같다 테스트 및 발표 자료 준비 등을 하는 1주일을 제외하면 이제 사실상 순수 개발 시간은 1주일 정도 남았는데 이제 본격적인 게임 구현을 시작한다.

### 👀solution

주말동안도 열심히 하자...

# 📌to do

- nginx (웹소켓) wss 설정
- 게임 로직 역할 어떻게 분담할지 결정
- 게임 부분 컴포넌트 및 폴더 구조 정리
- 상점, 옷장 부분 코드 액세스 토큰 추가 및 리팩토링
- 상점 뒤로 버튼 눌러서 착용 확정 api 요청 구현

# 📚3주차 KPT 회고

## 👍keep

- 로그인 로직을 완벽한 보안으로 해냄
- 즐기는 마음으로 임함

## 👎problem

- 개개인은 열심히 했지만 합친 내용의 진행속도가 느리다.

## 🚀try

- 주말을 이용해서 열심히 합치는 작업을 진행할 예정
- 팀원들끼리 다독여주고 심적안정을 느낄 수 있도록 도와준다.

</details>
